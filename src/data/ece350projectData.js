export const ece350projectData = {
    title: "Mini Elevator",
    description1: "This project aimed to design and implement a functional elevator system for a multi-story building using a FPGA and readily available components such as buttons, LEDs, motors, belts, speakers, and laser-cut or 3D-printed parts.",
    description2: "The elevator operated using a fishing line connected to a motor, moving based on a queue that stored up to five button presses. Our 100-line MIPS code managed inputs, outputs, and the FIFO queue controlling the elevator. The code processed button inputs, updated the queue, determined the elevator movement, and sent commands to the FPGA. The FPGA 7-segment displays showed the current and queued floors, updating as the elevator moved. LEDs on the button box indicated the elevator target, using data from hall-effect sensors and Verilog code. ",
    sensordiagrams: "The Development",
    description3: "Initial Idea",
    description4: "We originally proposed that pressing the button on each floor would move the elevator to that floor. The elevator would play music while in motion and ding upon reaching its destination. Once the elevator arrived, a green LED would light up, and the sliding door would open for a set time before closing automatically. Floors would be queued in the order their respective buttons were pressed, with the elevator moving to each floor in sequence. Our plan was to laser-cut and assemble both the building and the elevator. The elevator and automatic doors were designed to operate using a belt and motor system, which would spin in the necessary direction. To implement this, we proposed purchasing motors for moving the elevator and the doors. We also planned to use magnets and a hall-effect sensor to detect specific floors, allowing the elevator to stop briefly. Here is what the original drawing looked like:",
    description5: "The Implementation",
    description6: "We initially received a DC motor, four hall-effect sensors, four LED buttons, and a trigger switch drive module. With these components, we created two circuits using a breadboard—one for the hall-effect sensors and another for the buttons—and began testing them with behavioral Verilog.",
    description7: "The hall-effect sensors functioned by outputting half of the input voltage (2.5V) when no magnet was present. When a magnet was detected, the output would change to either 0V or 5V, depending on the magnet's polarity. We implemented this by feeding the hall-effect sensor outputs into the FPGA. In its neutral state (2.5V), the FPGA treated the signal as HIGH. The positive side of the magnet would still output a HIGH signal at 5V, so we used the negative side of the magnet for the FPGA to detect a magnet's presence.",
    description8: "The buttons were used to select which magnet corresponded to the destination floor. The buttons had built-in LEDs, which we used to indicate the next destination. Initially, the destination hall-effect sensor was linked to the most recently pressed button, and its corresponding LED would light up. As we implemented the queue, the LED logic was updated so that the LED for the current destination—the top of the queue—would light up. During testing, we utilized the LEDs on the FPGA to verify our logic and code, assigning LEDs to specific components like hall-effect sensors and buttons. This made it easier to identify if a component was functioning correctly. It is important to note that we did not modify our processor, and the entire project ran on a 100 MHz clock.",
    description9: "After testing on the breadboard, we replicated the circuits on protoboards, 3D printed parts, and assembled the final product. We tested the protoboards for continuity with a multimeter. The hall-effect and button protoboards were completed, with the buttons enclosed in a 3D-printed box (4x4x2 inches) and soldered in place. Testing the enclosed buttons was more tedious. The building, designed with each floor measuring 2x2.5x0.8 inches, resulted in a total height of 8 inches.",
    description10: "Our MIPS code, approximately 100 lines long, managed input/outputs and implemented the FIFO queue. It comprised four main stages: reading and processing inputs, managing the queue, determining movement, and sending data to the board. We used the lw instruction with specific addresses for button inputs, ensuring only one button press was registered per clock cycle. Inputs were processed to update the queue, which had a fixed size of six, using manual shifting in assembly. The FIFO queue's head represented the current destination, and we calculated the movement direction and motor duty cycle accordingly. Data was sent to the FPGA by specifying addresses for the 7-segment displays, button LEDs, and motor outputs.",
    description11: "After successfully implementing the RecyclerView, the final step in the project was dedicated to enhancing its visual appeal. I opted for a color theme of vibrant shades of red, orange, and peach. In addition to the color scheme, I carefully selected fonts to complement the theme. Ultimately, I settled on the use of Aladin, Architects_Daughter, and Atomic_Age fonts, which significantly contributed to the overall visual charm of the end product. This thoughtful combination of colors and fonts resulted in a final product that was not only functional but also visually appealing, allowing for the best user experience possible. This final product is what's shown at the very top of the page.",
    backlink: '/projects',
}